{"version":3,"sources":["../__obj/src/Context.js"],"names":["assert","Context","dispatcher","store","validateInstance","_dispatcher","_storeGroup","_releaseHandlers","releaseHandler","pipe","push","getState","onChange","handler","useCase","isUseCase","parent","ok","Object","getPrototypeOf","functionalUseCase","Error","onWillExecuteEachUseCase","onDispatch","payload","meta","isTrusted","onDidExecuteEachUseCase","onCompleteEachUseCase","onErrorDispatch","release","storeGroup","forEach","length"],"mappings":"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","file":"Context.js","sourcesContent":["// LICENSE : MIT\n\"use strict\";\nimport * as assert from \"assert\";\nimport { UseCase } from \"./UseCase\";\nimport { UseCaseExecutor } from \"./UseCaseExecutor\";\nimport { StoreGroupValidator } from \"./UILayer/StoreGroupValidator\";\n// payloads\nimport { isCompletedPayload } from \"./payload/CompletedPayload\";\nimport { isDidExecutedPayload } from \"./payload/DidExecutedPayload\";\nimport { isErrorPayload } from \"./payload/ErrorPayload\";\nimport { isWillExecutedPayload } from \"./payload/WillExecutedPayload\";\nimport { FunctionalUseCase } from \"./FunctionalUseCase\";\n/**\n * Context class provide observing and communicating with **Store** and **UseCase**.\n */\nexport class Context {\n    /**\n     * `dispatcher` is an instance of `Dispatcher`.\n     * `store` is an instance of StoreLike implementation\n     *\n     * ### Example\n     *\n     * It is minimal initialization.\n     *\n     * ```js\n     * const context = new Context({\n     *   dispatcher: new Dispatcher(),\n     *   store: new Store()\n     * });\n     * ```\n     *\n     * In real case, you can pass `StoreGroup` instead of `Store`.\n     *\n     * ```js\n     * const storeGroup = new StoreGroup([\n     *   new AStore(), new BStore(), new CStore()\n     * ]);\n     * const context = new Context({\n     *   dispatcher: new Dispatcher(),\n     *   store: new Store()\n     * });\n     * ```\n     */\n    constructor({ dispatcher, store }) {\n        StoreGroupValidator.validateInstance(store);\n        // central dispatcher\n        this._dispatcher = dispatcher;\n        this._storeGroup = store;\n        /**\n         * callable release handlers\n         * @type {Function[]}\n         * @private\n         */\n        this._releaseHandlers = [];\n        // Implementation Note:\n        // Delegate dispatch event to Store|StoreGroup from Dispatcher\n        // Dispatch Flow: Dispatcher -> StoreGroup -> Store\n        const releaseHandler = this._dispatcher.pipe(this._storeGroup);\n        this._releaseHandlers.push(releaseHandler);\n    }\n    /**\n     * Return state value of StoreGroup or Store.\n     *\n     * ### Example\n     *\n     * If you pass `StoreGroup` to `store` of Constructor,\n     * `Context#getState()` return the state object that merge each stores's state.\n     *\n     * ```js\n     * const state = context.getState();\n     * console.log(state);\n     * // { aState, bState }\n     * ```\n     */\n    getState() {\n        return this._storeGroup.getState();\n    }\n    /**\n     * If anyone store that is passed to constructor is changed, then call `onChange`.\n     * `onChange` arguments is an array of `Store` instances.\n     *\n     * It returns unSubscribe function.\n     * If you want to release handler, the returned function.\n     *\n     * ### Example\n     *\n     * ```js\n     * const unSubscribe = context.onChange(changingStores => {\n     *   console.log(changingStores); // Array<Store>\n     * });\n     * ```\n     */\n    onChange(handler) {\n        return this._storeGroup.onChange(handler);\n    }\n    useCase(useCase) {\n        // instance of UseCase\n        if (UseCase.isUseCase(useCase)) {\n            return new UseCaseExecutor({\n                useCase,\n                parent: null,\n                dispatcher: this._dispatcher\n            });\n        }\n        else if (typeof useCase === \"function\") {\n            // When pass UseCase constructor itself, throw assertion error\n            assert.ok(Object.getPrototypeOf && Object.getPrototypeOf(useCase) !== UseCase, `Context#useCase argument should be instance of UseCase.\nThe argument is UseCase constructor itself: ${useCase}`);\n            // function to be FunctionalUseCase\n            const functionalUseCase = new FunctionalUseCase(useCase, this._dispatcher);\n            return new UseCaseExecutor({\n                useCase: functionalUseCase,\n                parent: null,\n                dispatcher: this._dispatcher\n            });\n        }\n        throw new Error(`Context#useCase argument should be UseCase: ${useCase}`);\n    }\n    /**\n     * Register `handler` function to Context.\n     * `handler` is called when each useCases will execute.\n     */\n    onWillExecuteEachUseCase(handler) {\n        const releaseHandler = this._dispatcher.onDispatch((payload, meta) => {\n            if (isWillExecutedPayload(payload)) {\n                handler(payload, meta);\n            }\n        });\n        this._releaseHandlers.push(releaseHandler);\n        return releaseHandler;\n    }\n    /**\n     * Register `handler` function to Context.\n     * `handler` is called the `handler` with user-defined payload object when the UseCase dispatch with payload.\n     * This `onDispatch` is not called at built-in event. It is filtered by Context.\n     * If you want to *All* dispatched event and use listen directly your `dispatcher` object.\n     * In other word, listen the dispatcher of `new Context({dispatcher})`.\n     *\n     * ### Example\n     *\n     * ```js\n     * const dispatchUseCase = ({dispatcher}) => {\n     *   return () => dispatcher.dispatch({ type: \"fired-payload\" });\n     * };\n     * context.onDispatch((payload, meta) => {\n     *   console.log(payload); // { type: \"fired-payload\" }\n     * });\n     *\n     * context.useCase(dispatchUseCase).execute();\n     * ```\n     */\n    onDispatch(handler) {\n        const releaseHandler = this._dispatcher.onDispatch((payload, meta) => {\n            // call handler, if payload's type is not built-in event.\n            // It means that `onDispatch` is called when dispatching user event.\n            if (!meta.isTrusted) {\n                handler(payload, meta);\n            }\n        });\n        this._releaseHandlers.push(releaseHandler);\n        return releaseHandler;\n    }\n    /**\n     * `handler` is called when each useCases are executed.\n     */\n    onDidExecuteEachUseCase(handler) {\n        const releaseHandler = this._dispatcher.onDispatch((payload, meta) => {\n            if (isDidExecutedPayload(payload)) {\n                handler(payload, meta);\n            }\n        });\n        this._releaseHandlers.push(releaseHandler);\n        return releaseHandler;\n    }\n    /**\n     * `handler` is called when each useCases are completed.\n     * This `handler` is always called asynchronously.\n     */\n    onCompleteEachUseCase(handler) {\n        const releaseHandler = this._dispatcher.onDispatch((payload, meta) => {\n            if (isCompletedPayload(payload)) {\n                handler(payload, meta);\n            }\n        });\n        this._releaseHandlers.push(releaseHandler);\n        return releaseHandler;\n    }\n    /**\n     * `handler` is called when some UseCase throw Error.\n     *\n     * Throwing Error is following case:\n     *\n     * - Throw exception in a UseCase\n     * - Return rejected promise in a UseCase\n     * - Call `UseCase#throwError(error)`\n     */\n    onErrorDispatch(handler) {\n        const releaseHandler = this._dispatcher.onDispatch((payload, meta) => {\n            if (isErrorPayload(payload)) {\n                handler(payload, meta);\n            }\n        });\n        this._releaseHandlers.push(releaseHandler);\n        return releaseHandler;\n    }\n    /**\n     * Release all events handler in Context.\n     * You can call this when no more call event handler\n     */\n    release() {\n        const storeGroup = this._storeGroup;\n        if (storeGroup) {\n            storeGroup.release();\n        }\n        this._releaseHandlers.forEach(releaseHandler => releaseHandler());\n        this._releaseHandlers.length = 0;\n    }\n}\n"]}