{"version":3,"sources":["../__obj/src/UseCaseExecutor.js"],"names":["assert","warningUseCaseIsAlreadyReleased","parentUseCase","useCase","payload","meta","console","warn","name","UseCaseExecutor","parent","dispatcher","process","env","NODE_ENV","useCaseName","ok","execute","_useCase","_parentUseCase","_dispatcher","_releaseHandlers","unListenHandler","pipe","push","_willExecute","args","set","isTrusted","isUseCaseFinished","dispatch","has","_didExecute","isFinished","value","_complete","delete","onWillExecuteEachUseCase","handler","releaseHandler","onDispatch","onWillExecute","onDidExecuteEachUseCase","onDidExecuted","onCompleteExecuteEachUseCase","onCompleted","result","isResultPromise","then","Promise","resolve","release","catch","throwError","error","reject","forEach","length"],"mappings":"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","file":"UseCaseExecutor.js","sourcesContent":["// LICENSE : MIT\n\"use strict\";\nimport * as assert from \"assert\";\nimport { DispatcherPayloadMetaImpl } from \"./DispatcherPayloadMeta\";\nimport { UseCaseInstanceMap } from \"./UseCaseInstanceMap\";\n// payloads\nimport { CompletedPayload, isCompletedPayload } from \"./payload/CompletedPayload\";\nimport { DidExecutedPayload, isDidExecutedPayload } from \"./payload/DidExecutedPayload\";\nimport { WillExecutedPayload, isWillExecutedPayload } from \"./payload/WillExecutedPayload\";\n/**\n * When child is completed after parent did completed, display warning warning message\n * @private\n */\nconst warningUseCaseIsAlreadyReleased = (parentUseCase, useCase, payload, meta) => {\n    console.warn(`${useCase.name}'s parent UseCase(${parentUseCase.name}) is already released.\nThis UseCase(${useCase.name}) will not work correctly.\nhttps://almin.js.org/docs/warnings/usecase-is-already-released.html\n`, payload, meta);\n};\n/**\n * `UseCaseExecutor` is a helper class for executing UseCase.\n *\n * You can not create the instance of UseCaseExecutor directory.\n * You can get the instance by `Context#useCase(useCase)`,\n *\n * @private\n */\nexport class UseCaseExecutor {\n    /**\n     * @param   useCase\n     * @param   parent\n     *      parent is parent of `useCase`\n     * @param   dispatcher\n     * @public\n     *\n     * **internal** documentation\n     */\n    constructor({ useCase, parent, dispatcher }) {\n        if (process.env.NODE_ENV !== \"production\") {\n            // execute and finish =>\n            const useCaseName = useCase.name;\n            assert.ok(typeof useCaseName === \"string\", `UseCase instance should have constructor.name ${useCase}`);\n            assert.ok(typeof useCase.execute === \"function\", `UseCase instance should have #execute function: ${useCaseName}`);\n        }\n        this._useCase = useCase;\n        this._parentUseCase = parent;\n        this._dispatcher = dispatcher;\n        this._releaseHandlers = [];\n        // delegate userCase#onDispatch to central dispatcher\n        const unListenHandler = this._useCase.pipe(this._dispatcher);\n        this._releaseHandlers.push(unListenHandler);\n    }\n    /**\n     * @param   [args] arguments of the UseCase\n     */\n    _willExecute(args) {\n        // Add instance to manager\n        // It should be removed when it will be completed.\n        UseCaseInstanceMap.set(this._useCase, this);\n        const payload = new WillExecutedPayload({\n            args\n        });\n        const meta = new DispatcherPayloadMetaImpl({\n            useCase: this._useCase,\n            dispatcher: this._dispatcher,\n            parentUseCase: this._parentUseCase,\n            isTrusted: true,\n            isUseCaseFinished: false\n        });\n        this._dispatcher.dispatch(payload, meta);\n        // Warning: parentUseCase is already released\n        if (process.env.NODE_ENV !== \"production\") {\n            if (this._parentUseCase && !UseCaseInstanceMap.has(this._parentUseCase)) {\n                warningUseCaseIsAlreadyReleased(this._parentUseCase, this._useCase, payload, meta);\n            }\n        }\n    }\n    /**\n     * dispatch did execute each UseCase\n     */\n    _didExecute(isFinished, value) {\n        const payload = new DidExecutedPayload({\n            value\n        });\n        const meta = new DispatcherPayloadMetaImpl({\n            useCase: this._useCase,\n            dispatcher: this._dispatcher,\n            parentUseCase: this._parentUseCase,\n            isTrusted: true,\n            isUseCaseFinished: isFinished\n        });\n        this._dispatcher.dispatch(payload, meta);\n    }\n    /**\n     * dispatch complete each UseCase\n     * @param   [value] unwrapped result value of the useCase executed\n     */\n    _complete(value) {\n        const payload = new CompletedPayload({\n            value\n        });\n        const meta = new DispatcherPayloadMetaImpl({\n            useCase: this._useCase,\n            dispatcher: this._dispatcher,\n            parentUseCase: this._parentUseCase,\n            isTrusted: true,\n            isUseCaseFinished: true\n        });\n        this._dispatcher.dispatch(payload, meta);\n        // Warning: parentUseCase is already released\n        if (process.env.NODE_ENV !== \"production\") {\n            if (this._parentUseCase && !UseCaseInstanceMap.has(this._parentUseCase)) {\n                warningUseCaseIsAlreadyReleased(this._parentUseCase, this._useCase, payload, meta);\n            }\n        }\n        // Delete the reference from instance manager\n        // It prevent leaking of instance.\n        UseCaseInstanceMap.delete(this._useCase);\n    }\n    /**\n     * called the {@link handler} with useCase when the useCase will do.\n     * @param   handler\n     */\n    onWillExecuteEachUseCase(handler) {\n        const releaseHandler = this._dispatcher.onDispatch(function onWillExecute(payload, meta) {\n            if (isWillExecutedPayload(payload)) {\n                handler(payload, meta);\n            }\n        });\n        this._releaseHandlers.push(releaseHandler);\n        return releaseHandler;\n    }\n    /**\n     * called the `handler` with useCase when the useCase is executed.\n     * @param   handler\n     */\n    onDidExecuteEachUseCase(handler) {\n        const releaseHandler = this._dispatcher.onDispatch(function onDidExecuted(payload, meta) {\n            if (isDidExecutedPayload(payload)) {\n                handler(payload, meta);\n            }\n        });\n        this._releaseHandlers.push(releaseHandler);\n        return releaseHandler;\n    }\n    /**\n     * called the `handler` with useCase when the useCase is completed.\n     * @param   handler\n     * @returns\n     */\n    onCompleteExecuteEachUseCase(handler) {\n        const releaseHandler = this._dispatcher.onDispatch(function onCompleted(payload, meta) {\n            if (isCompletedPayload(payload)) {\n                handler(payload, meta);\n            }\n        });\n        this._releaseHandlers.push(releaseHandler);\n        return releaseHandler;\n    }\n    execute(...args) {\n        this._willExecute(args);\n        const result = this._useCase.execute(...args);\n        const isResultPromise = result && typeof result.then == \"function\";\n        // if the UseCase return a promise, almin recognize the UseCase as continuous.\n        // In other word, If the UseCase want to continue, please return a promise object.\n        const isUseCaseFinished = !isResultPromise;\n        // Sync call didExecute\n        this._didExecute(isUseCaseFinished, result);\n        // Async call complete\n        return Promise.resolve(result).then((result) => {\n            this._complete(result);\n            this.release();\n        }).catch(error => {\n            this._useCase.throwError(error);\n            this._complete();\n            this.release();\n            return Promise.reject(error);\n        });\n    }\n    /**\n     * release all events handler.\n     * You can call this when no more call event handler\n     */\n    release() {\n        this._releaseHandlers.forEach(releaseHandler => releaseHandler());\n        this._releaseHandlers.length = 0;\n    }\n}\n"]}