{"version":3,"sources":["../../__obj/src/UILayer/StoreGroup.js"],"names":["assert","CHANGE_STORE_GROUP","InitializedPayload","type","initializedPayload","assertConstructorArguments","arg","message","ok","Array","isArray","keys","Object","i","length","key","value","isStore","warningStateIsImmutable","prevState","nextState","store","changingStores","shouldStateUpdate","isChangingStore","indexOf","isStateChanged","console","warn","name","hasOwnProperty","state","isStatePropertyChanged","isStateChangedButShouldNotUpdate","StoreGroup","stateStoreMapping","_emitChangedStores","_changingStores","_releaseHandlers","process","env","NODE_ENV","_storeStateMap","stores","_workingUseCaseMap","_finishedUseCaseMap","_stateCacheMap","forEach","registerHandler","_registerStore","push","pipeHandler","pipe","_observeDispatchedPayload","initializeGroupState","getState","payload","writePhaseInRead","readPhaseInRead","receivePayload","groupState","get","stateName","undefined","set","_addChangingStateOfStores","emitChange","tryEmitChange","sendPayloadAndTryEmit","_pruneChangingStateOfStores","slice","emit","_pruneEmitChangedStore","onChange","handler","on","releaseHandler","removeListener","bind","release","onChangeHandler","addEmitChangedStore","existWorkingUseCase","displayName","observeChangeHandler","meta","isTrusted","useCase","id","isUseCaseFinished","delete","has","onDispatch","size"],"mappings":"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","file":"StoreGroup.js","sourcesContent":["// MIT Â© 2017 azu\n\"use strict\";\nimport * as assert from \"assert\";\nimport MapLike from \"map-like\";\nimport { Payload } from \"../payload/Payload\";\nimport { ErrorPayload } from \"../payload/ErrorPayload\";\nimport { WillExecutedPayload } from \"../payload/WillExecutedPayload\";\nimport { DidExecutedPayload } from \"../payload/DidExecutedPayload\";\nimport { CompletedPayload } from \"../payload/CompletedPayload\";\nimport { shallowEqual } from \"shallow-equal-object\";\nimport { Dispatcher } from \"../Dispatcher\";\nimport { createStoreStateMap } from \"./StoreStateMap\";\nimport { Store } from \"../Store\";\nconst CHANGE_STORE_GROUP = \"CHANGE_STORE_GROUP\";\n/**\n * Initialized Payload\n * This is exported for an unit testing.\n * DO NOT USE THIS in your application.\n */\nexport class InitializedPayload extends Payload {\n    constructor() {\n        super({ type: \"Almin__InitializedPayload__\" });\n    }\n}\n// InitializedPayload for passing to Store if the state change is not related payload.\nconst initializedPayload = new InitializedPayload();\n/**\n * assert: check arguments of constructor.\n */\nconst assertConstructorArguments = (arg) => {\n    const message = `Should initialize this StoreGroup with a stateName-store mapping object.\nconst aStore = new AStore();\nconst bStore = new BStore();\n// A arguments is stateName-store mapping object like { stateName: store }\nconst storeGroup = new CQRSStoreGroup({\n    a: aStore,\n    b: bStore\n});\nconsole.log(storeGroup.getState());\n// { a: \"a value\", b: \"b value\" }\n`;\n    assert.ok(typeof arg === \"object\" && arg !== null && !Array.isArray(arg), message);\n    const keys = Object.keys(arg);\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = arg[key];\n        // Don't checking for accepting string or symbol.\n        // assert.ok(typeof key === \"string\", `key should be string type: ${key}: ${value}` + \"\\n\" + message);\n        assert.ok(Store.isStore(value), `value should be instance of Store: ${key}: ${value}` + \"\\n\" + message);\n    }\n};\n/**\n * warning: check immutability of the `store`'s state\n * If the store call `Store#emitChange()` and the state of store is not changed, throw error.\n * https://github.com/almin/almin/issues/151\n */\nconst warningStateIsImmutable = (prevState, nextState, store, changingStores) => {\n    const shouldStateUpdate = (prevState, nextState) => {\n        if (typeof store.shouldStateUpdate === \"function\") {\n            return store.shouldStateUpdate(prevState, nextState);\n        }\n        return prevState !== nextState;\n    };\n    // If the store emitChange, check immutability\n    const isChangingStore = changingStores.indexOf(store) !== -1;\n    if (isChangingStore) {\n        const isStateChanged = shouldStateUpdate(prevState, nextState);\n        if (!isStateChanged) {\n            console.warn(`Store(${store.name}) does call emitChange(). \nBut, this store's state is not changed.\nStore's state should be immutable value.\nPrev State:`, prevState, `Next State:`, nextState);\n        }\n    }\n    // If the store return **changed** state, but shouldStateUpdate return false.\n    // This checker aim to find updating that is not reflected to UI.\n    if (!store.hasOwnProperty(\"state\")) {\n        return;\n    }\n    // store.state is not same with getState value\n    // It means `store.state` is not related with getState\n    if (store.state !== nextState) {\n        return;\n    }\n    const isStatePropertyChanged = prevState !== nextState;\n    const isStateChangedButShouldNotUpdate = isStatePropertyChanged && !shouldStateUpdate(prevState, nextState);\n    if (isStateChangedButShouldNotUpdate) {\n        console.warn(`${store.name}#state property is changed, but this change does not reflect to view.\nBecause, ${store.name}#shouldStateUpdate(prevState, store.state) has returned **false**.\nIt means that the variance is present between store's state and shouldStateUpdate.\nYou should update the state vis \\`Store#setState\\` method.\n\nFor example, you should update the state by following:\n\n    this.setState(newState);\n    \n    // OR\n\n    if(this.shouldStateUpdate(this.state, newState)){\n        this.state = newState;\n    }\n`, \"prevState\", prevState, \"nextState\", nextState);\n    }\n};\n/**\n * StoreGroup is a parts of read-model.\n *\n * StoreGroup has separated two phase in a life-cycle.\n * These are called Write phase and Read phase.\n *\n * StoreGroup often does write phase and, then read phase.\n *\n * ## Write phase\n *\n * StoreGroup notify update timing for each stores.\n *\n * It means that call each `Store#receivePayload()`.\n *\n * ### When\n *\n * - Initialize StoreGroup\n * - A parts of life-cycle during execute UseCase\n * - Force update StoreGroup\n *\n * ### What does store?\n *\n * - Store update own state if needed\n *\n * ### What does not store?\n *\n * - Store should not directly assign to state instead of using `Store#setState`\n *\n * ## Read phase\n *\n * StoreGroup read the state from each stores.\n *\n * It means that call each `Store#getState()`.\n *\n * ### When\n *\n * - Initialize StoreGroup\n * - A parts of life-cycle during execute UseCase\n * - Force update StoreGroup\n * - Some store call `Store#emitChange`\n *\n * ### What does store?\n *\n * - Store return own state\n *\n * ### What does not store?\n *\n * - Does not update own state\n * - Please update own state in write phase\n *\n * ### Notes\n *\n * #### Pull-based: Recompute every time value is needed\n *\n * Pull-based Store has only getState.\n * Just create the state and return it when `getState` is called.\n *\n * #### Push-based: Recompute when a source value changes\n *\n * Push-based Store have to create the state and save it.\n * Just return the state when `getState` is called.\n * It is similar with cache system.\n *\n */\nexport class StoreGroup extends Dispatcher {\n    /**\n     * Initialize this StoreGroup with a stateName-store mapping object.\n     *\n     * The rule of initializing StoreGroup is that \"define the state name of the store\".\n     *\n     * ## Example\n     *\n     * Initialize with store-state mapping object.\n     *\n     * ```js\n     * class AStore extends Store {\n     *     getState() {\n     *         return \"a value\";\n     *     }\n     * }\n     * class BStore extends Store {\n     *     getState() {\n     *         return \"b value\";\n     *     }\n     * }\n     * const aStore = new AStore();\n     * const bStore = new BStore();\n     * const storeGroup = new CQRSStoreGroup({\n     *     a: aStore, // stateName: store\n     *     b: bStore\n     * });\n     * console.log(storeGroup.getState());\n     * // { a: \"a value\", b: \"b value\" }\n     * ```\n     */\n    constructor(stateStoreMapping) {\n        super();\n        this.stateStoreMapping = stateStoreMapping;\n        // stores that are emitted changed.\n        this._emitChangedStores = [];\n        // stores that are changed compared by previous state.\n        this._changingStores = [];\n        // all functions to release handlers\n        this._releaseHandlers = [];\n        if (process.env.NODE_ENV !== \"production\") {\n            assertConstructorArguments(stateStoreMapping);\n        }\n        this._storeStateMap = createStoreStateMap(stateStoreMapping);\n        // pull stores from mapping if arguments is mapping.\n        this.stores = this._storeStateMap.stores;\n        this._workingUseCaseMap = new MapLike();\n        this._finishedUseCaseMap = new MapLike();\n        this._stateCacheMap = new MapLike();\n        // Implementation Note:\n        // Dispatch -> pipe -> Store#emitChange() if it is needed\n        //          -> this.onDispatch -> If anyone store is changed, this.emitChange()\n        // each pipe to dispatching\n        this.stores.forEach((store) => {\n            // observe Store\n            const registerHandler = this._registerStore(store);\n            this._releaseHandlers.push(registerHandler);\n            // delegate dispatching\n            const pipeHandler = this.pipe(store);\n            this._releaseHandlers.push(pipeHandler);\n        });\n        // after dispatching, and then emitChange\n        this._observeDispatchedPayload();\n        // default state\n        this.state = this.initializeGroupState(this.stores, initializedPayload);\n    }\n    /**\n     * If exist working UseCase, return true\n     */\n    get existWorkingUseCase() {\n        return this._workingUseCaseMap.size > 0;\n    }\n    get isInitializedWithStateNameMap() {\n        return this._storeStateMap.size > 0;\n    }\n    /**\n     * Return the state object that merge each stores's state\n     */\n    getState() {\n        return this.state;\n    }\n    initializeGroupState(stores, payload) {\n        // 1. write in read\n        this.writePhaseInRead(stores, payload);\n        // 2. read in read\n        return this.readPhaseInRead(stores);\n    }\n    // write phase\n    // Each store updates own state\n    writePhaseInRead(stores, payload) {\n        for (let i = 0; i < stores.length; i++) {\n            const store = stores[i];\n            // reduce state by prevSate with payload if it is implemented\n            if (typeof store.receivePayload === \"function\") {\n                store.receivePayload(payload);\n            }\n        }\n    }\n    // read phase\n    // Get state from each store\n    readPhaseInRead(stores) {\n        const groupState = {};\n        for (let i = 0; i < stores.length; i++) {\n            const store = stores[i];\n            const prevState = this._stateCacheMap.get(store);\n            const nextState = store.getState();\n            // if the prev/next state is same, not update the state.\n            const stateName = this._storeStateMap.get(store);\n            if (process.env.NODE_ENV !== \"production\") {\n                assert.ok(stateName !== undefined, `Store:${store.name} is not registered in constructor.\nBut, ${store.name}#getState() was called.`);\n                warningStateIsImmutable(prevState, nextState, store, this._emitChangedStores);\n            }\n            // the state is not changed, set prevState as state of the store\n            // Check shouldStateUpdate\n            if (typeof store.shouldStateUpdate === \"function\") {\n                if (!store.shouldStateUpdate(prevState, nextState)) {\n                    groupState[stateName] = prevState;\n                    continue;\n                }\n            }\n            else {\n                if (prevState === nextState) {\n                    groupState[stateName] = prevState;\n                    continue;\n                }\n            }\n            // Update cache\n            this._stateCacheMap.set(store, nextState);\n            // Changing flag On\n            this._addChangingStateOfStores(store);\n            // Set state\n            groupState[stateName] = nextState;\n        }\n        return groupState;\n    }\n    /**\n     * Use `shouldStateUpdate()` to let StoreGroup know if a event is not affected.\n     * The default behavior is to emitChange on every life-cycle change,\n     * and in the vast majority of cases you should rely on the default behavior.\n     * Default behavior is shallow-equal prev/next state.\n     *\n     * ## Example\n     *\n     * If you want to use `Object.is` to equal states, overwrite following.\n     *\n     * ```js\n     * shouldStateUpdate(prevState, nextState) {\n     *    return !Object.is(prevState, nextState)\n     * }\n     * ```\n     */\n    shouldStateUpdate(prevState, nextState) {\n        return !shallowEqual(prevState, nextState);\n    }\n    /**\n     * Emit change if the state is changed.\n     * If call with no-arguments, use ChangedPayload by default.\n     */\n    emitChange() {\n        this.tryEmitChange();\n    }\n    // write and read -> emitChange if needed\n    sendPayloadAndTryEmit(payload) {\n        this.writePhaseInRead(this.stores, payload);\n        this.tryEmitChange();\n    }\n    // read -> emitChange if needed\n    tryEmitChange() {\n        this._pruneChangingStateOfStores();\n        const nextState = this.readPhaseInRead(this.stores);\n        if (!this.shouldStateUpdate(this.state, nextState)) {\n            return;\n        }\n        this.state = nextState;\n        // emit changes\n        const changingStores = this._changingStores.slice();\n        this.emit(CHANGE_STORE_GROUP, changingStores);\n        // release changed stores\n        this._pruneEmitChangedStore();\n    }\n    /**\n     * Observe changes of the store group.\n     *\n     * onChange workflow: https://code2flow.com/mHFviS\n     */\n    onChange(handler) {\n        this.on(CHANGE_STORE_GROUP, handler);\n        const releaseHandler = this.removeListener.bind(this, CHANGE_STORE_GROUP, handler);\n        this._releaseHandlers.push(releaseHandler);\n        return releaseHandler;\n    }\n    /**\n     * Release all events handler.\n     * You can call this when no more call event handler\n     */\n    release() {\n        this._releaseHandlers.forEach(releaseHandler => releaseHandler());\n        this._releaseHandlers.length = 0;\n        this._pruneChangingStateOfStores();\n    }\n    /**\n     * register store and listen onChange.\n     * If you release store, and do call `release` method.\n     */\n    _registerStore(store) {\n        const onChangeHandler = () => {\n            this.addEmitChangedStore(store);\n            // if not exist working UseCases, immediate invoke emitChange.\n            if (!this.existWorkingUseCase) {\n                this.tryEmitChange();\n            }\n        };\n        if (process.env.NODE_ENV !== \"production\") {\n            onChangeHandler.displayName = `${store.name}#onChange->handler`;\n        }\n        return store.onChange(onChangeHandler);\n    }\n    /**\n     * Observe all payload.\n     */\n    _observeDispatchedPayload() {\n        const observeChangeHandler = (payload, meta) => {\n            if (!meta.isTrusted) {\n                this.sendPayloadAndTryEmit(payload);\n            }\n            else if (payload instanceof ErrorPayload) {\n                this.sendPayloadAndTryEmit(payload);\n            }\n            else if (payload instanceof WillExecutedPayload && meta.useCase) {\n                this._workingUseCaseMap.set(meta.useCase.id, true);\n            }\n            else if (payload instanceof DidExecutedPayload && meta.useCase) {\n                if (meta.isUseCaseFinished) {\n                    this._finishedUseCaseMap.set(meta.useCase.id, true);\n                }\n                this.sendPayloadAndTryEmit(payload);\n            }\n            else if (payload instanceof CompletedPayload && meta.useCase && meta.isUseCaseFinished) {\n                this._workingUseCaseMap.delete(meta.useCase.id);\n                // if the useCase is already finished, doesn't emitChange in CompletedPayload\n                // In other word, If the UseCase that return non-promise value, doesn't emitChange in CompletedPayload\n                if (this._finishedUseCaseMap.has(meta.useCase.id)) {\n                    this._finishedUseCaseMap.delete(meta.useCase.id);\n                    return;\n                }\n                this.sendPayloadAndTryEmit(payload);\n            }\n        };\n        const releaseHandler = this.onDispatch(observeChangeHandler);\n        this._releaseHandlers.push(releaseHandler);\n    }\n    addEmitChangedStore(store) {\n        if (this._emitChangedStores.indexOf(store) === -1) {\n            this._emitChangedStores.push(store);\n        }\n    }\n    _pruneEmitChangedStore() {\n        this._emitChangedStores = [];\n    }\n    _addChangingStateOfStores(store) {\n        if (this._changingStores.indexOf(store) === -1) {\n            this._changingStores.push(store);\n        }\n    }\n    _pruneChangingStateOfStores() {\n        this._changingStores = [];\n    }\n}\n"]}