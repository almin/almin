{"version":3,"sources":["../__obj/src/UseCaseContext.js"],"names":["assert","require","UseCaseContext","dispatcher","_dispatcher","useCase","process","env","NODE_ENV","isUseCase","parent","ok","Object","getPrototypeOf","functionalUseCase","Error"],"mappings":"AAAA;AACA;;;;;;;AACA;;AACA;;AACA;;;;AACA,IAAMA,SAASC,QAAQ,QAAR,CAAf;AACA;;;;;;;;;;;;;;;;IAeaC,c;AACT;;;;;;;AAOA,4BAAYC,UAAZ,EAAwB;AAAA;;AACpB,aAAKC,WAAL,GAAmBD,UAAnB;AACH;;6BACDE,O,oBAAQA,Q,EAAS;AACb,YAAIC,QAAQC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACvCR,mBAAOK,aAAY,KAAKD,WAAxB,mBAAoDC,QAApD,wCAA8F,KAAKD,WAAnG;AACH;AACD,YAAI,iBAAQK,SAAR,CAAkBJ,QAAlB,CAAJ,EAAgC;AAC5B,mBAAO,qCAAoB;AACvBA,iCADuB;AAEvBK,wBAAQ,iBAAQD,SAAR,CAAkB,KAAKL,WAAvB,IAAsC,KAAKA,WAA3C,GAAyD,IAF1C;AAGvBD,4BAAY,KAAKC;AAHM,aAApB,CAAP;AAKH,SAND,MAOK,IAAI,OAAOC,QAAP,KAAmB,UAAvB,EAAmC;AACpC,gBAAIC,QAAQC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACvC;AACAR,uBAAOW,EAAP,CAAUC,OAAOC,cAAP,IAAyBD,OAAOC,cAAP,CAAsBR,QAAtB,sBAAnC,4GAC8BA,QAD9B;AAEH;AACD;AACA,gBAAMS,oBAAoB,yCAAsBT,QAAtB,EAA+B,KAAKD,WAApC,CAA1B;AACA,mBAAO,qCAAoB;AACvBC,yBAASS,iBADc;AAEvBJ,wBAAQ,iBAAQD,SAAR,CAAkB,KAAKL,WAAvB,IAAsC,KAAKA,WAA3C,GAAyD,IAF1C;AAGvBD,4BAAY,KAAKC;AAHM,aAApB,CAAP;AAKH;AACD,cAAM,IAAIW,KAAJ,yDAAgEV,QAAhE,CAAN;AACH,K","file":"UseCaseContext.js","sourcesContent":["// LICENSE : MIT\n\"use strict\";\nimport { UseCase } from \"./UseCase\";\nimport { UseCaseExecutor } from \"./UseCaseExecutor\";\nimport { FunctionalUseCase } from \"./FunctionalUseCase\";\nconst assert = require(\"assert\");\n/**\n * Maybe, `UseCaseContext` is invisible from Public API.\n *\n * `UseCase#context` return UseCaseContext insteadof Context.\n * It has limitation as against to Context.\n * Because, `UseCaseContext` is for `UseCase`, is not for `Context`.\n *\n * ```js\n * class ParentUseCase extends UseCase {\n *     execute() {\n *         this.context; // <= This is a instance of UseCaseContext\n *     }\n * }\n * ```\n */\nexport class UseCaseContext {\n    /**\n     * `dispatcher` is often parent `UseCase`.\n     * The user can not create this instance directly.\n     * The user can access this via `UseCase#context`\n     *\n     * **internal**\n     */\n    constructor(dispatcher) {\n        this._dispatcher = dispatcher;\n    }\n    useCase(useCase) {\n        if (process.env.NODE_ENV !== \"production\") {\n            assert(useCase !== this._dispatcher, `the useCase(${useCase}) should not equal this useCase(${this._dispatcher})`);\n        }\n        if (UseCase.isUseCase(useCase)) {\n            return new UseCaseExecutor({\n                useCase,\n                parent: UseCase.isUseCase(this._dispatcher) ? this._dispatcher : null,\n                dispatcher: this._dispatcher\n            });\n        }\n        else if (typeof useCase === \"function\") {\n            if (process.env.NODE_ENV !== \"production\") {\n                // When pass UseCase constructor itself, throw assertion error\n                assert.ok(Object.getPrototypeOf && Object.getPrototypeOf(useCase) !== UseCase, `Context#useCase argument should be instance of UseCase.\nThe argument is UseCase constructor itself: ${useCase}`);\n            }\n            // function to be FunctionalUseCase\n            const functionalUseCase = new FunctionalUseCase(useCase, this._dispatcher);\n            return new UseCaseExecutor({\n                useCase: functionalUseCase,\n                parent: UseCase.isUseCase(this._dispatcher) ? this._dispatcher : null,\n                dispatcher: this._dispatcher\n            });\n        }\n        throw new Error(`UseCaseContext#useCase argument should be UseCase: ${useCase}`);\n    }\n}\n"]}