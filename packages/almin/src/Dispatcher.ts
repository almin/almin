// LICENSE : MIT
"use strict";
import { EventEmitter } from "events";
import { DispatcherPayloadMeta, DispatcherPayloadMetaImpl } from "./DispatcherPayloadMeta";

import { Payload } from "./payload/Payload";
import { ErrorPayload } from "./payload/ErrorPayload";
import { CompletedPayload } from "./payload/CompletedPayload";
import { DidExecutedPayload } from "./payload/DidExecutedPayload";
import { WillExecutedPayload } from "./payload/WillExecutedPayload";
import { TransactionBeganPayload } from "./payload/TransactionBeganPayload";
import { TransactionEndedPayload } from "./payload/TransactionEndedPayload";
import { StoreChangedPayload } from "./payload/StoreChangedPayload";
import { AnyPayload } from "./payload/AnyPayload";
import { assertOK } from "./util/assert";

/**
 * @private
 */
export const ON_DISPATCH = "__ON_DISPATCH__";
/**
 * Payload object types.
 *
 * Almin has some built-in Payload class like `ErrorPayload`.
 * @private
 */
export type DispatchedPayload =
    | Payload
    | AnyPayload
    | ErrorPayload
    | CompletedPayload
    | DidExecutedPayload
    | WillExecutedPayload
    | TransactionBeganPayload
    | TransactionEndedPayload
    | StoreChangedPayload;

/**
 * Dispatcher is the **central** event bus system.
 *
 * `Dispatcher` class  have these method.
 *
 * - `onDispatch(function(payload){ });`
 * - `dispatch(payload);`
 *
 * It is similar with EventEmitter of Node.js
 * But, Dispatcher use `payload` object as arguments.
 *
 * ## Payload
 *
 * `payload` object must have `type` property.
 * Following object is a minimal `payload` object.
 *
 * ```json
 * {
 *     "type": "type"
 * }
 * ```
 *
 * Also, You can put any property to payload object.
 *
 * ```json
 * {
 *     "type": "show",
 *     "value": "value"
 * }
 * ```
 *
 * ### FAQ
 *
 * Q. Why Almin use `payload` object instead `emit(key, ...args)`?
 *
 * A. It is for optimization and limitation.
 * If apply emit style, we should cast `...args` for passing other dispatcher at every time.
 * So, Almin use `payload` object instead of it without casting.
 */
export class Dispatcher<Action extends AnyPayload = DispatchedPayload> extends EventEmitter {
    /**
     * if `v` is instance of Dispatcher, return true
     */
    static isDispatcher(v: any): v is Dispatcher<any> {
        if (v instanceof Dispatcher) {
            return true;
        } else if (typeof v === "object" && typeof v.onDispatch === "function" && typeof v.dispatch === "function") {
            return true;
        }
        return false;
    }

    /**
     * constructor not have arguments.
     **/
    constructor() {
        super();
        // suppress: memory leak warning of EventEmitter
        // Dispatcher can listen more than 10 events
        this.setMaxListeners(0);
    }

    /**
     * Add `handler`(subscriber) to Dispatcher and return unsubscribe function
     *
     * ### Example
     *
     * ```js
     * const dispatcher = new Dispatcher();
     * const unsubscribe = dispatcher.onDispatch((payload, meta) => {});
     * unsubscribe(); // release handler
     * ```
     */
    onDispatch(handler: (payload: Action, meta: DispatcherPayloadMeta) => void): () => void {
        this.on(ON_DISPATCH, handler);
        return this.removeListener.bind(this, ON_DISPATCH, handler);
    }

    /**
     * Dispatch `payload` to subscribers.
     */
    dispatch(payload: Action, meta?: DispatcherPayloadMeta): void {
        if (process.env.NODE_ENV !== "production") {
            assertOK(payload !== undefined && payload !== null, "payload should not null or undefined");
            assertOK(typeof payload.type !== "undefined", "payload's `type` should be required");
            if (meta !== undefined) {
                assertOK(meta instanceof DispatcherPayloadMetaImpl, "`meta` object is internal arguments.");
            }
        }
        // `meta` must be generated by system
        if (meta instanceof DispatcherPayloadMetaImpl) {
            this.emit(ON_DISPATCH, payload, meta);
        } else {
            // the `payload` object generated by user
            const dispatchOnlyMeta = new DispatcherPayloadMetaImpl({
                isTrusted: false
            });
            this.emit(ON_DISPATCH, payload, dispatchOnlyMeta);
        }
    }

    /**
     * Delegate payload object to other dispatcher.
     *
     * ### Example
     *
     * ```js
     * const a = new Dispatcher();
     * const b = new Dispatcher();
     * // Delegate `a` to `b`
     * a.pipe(b);
     * // dispatch and `b` can receive it.
     * a.dispatch({ type : "a" });
     * ```
     */
    pipe(toDispatcher: Dispatcher<Action>): () => void {
        const fromName = this.constructor.name;
        const toName = toDispatcher.constructor.name;
        const displayName = `delegate-payload:${fromName}-to-${toName}`;

        type DelegatePayloadFn = {
            (payload: Action, meta: DispatcherPayloadMeta): void;
            displayName: string;
        };
        const delegatePayload = function delegatePayload(payload: Action, meta: DispatcherPayloadMeta) {
            (delegatePayload as DelegatePayloadFn).displayName = displayName;
            toDispatcher.dispatch(payload, meta);
        };
        return this.onDispatch(delegatePayload);
    }
}
