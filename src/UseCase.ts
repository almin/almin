// LICENSE : MIT
"use strict";
import { Dispatcher } from "./Dispatcher";
import { DispatchedPayload } from "./Dispatcher";
import { UseCaseContext } from "./UseCaseContext";
import { DispatcherPayloadMeta, DispatcherPayloadMetaImpl } from "./DispatcherPayloadMeta";
import { ErrorPayload, isErrorPayload } from "./payload/ErrorPayload";
import { UseCaseLike } from "./UseCaseLike";
import { generateNewId } from "./UseCaseIdGenerator";

export const defaultUseCaseName = "<Anonymous-UseCase>";

/**
 * UseCase class is inherited Dispatcher.
 * The user implement own user-case that is inherited UseCase class
 * @example
 import {UseCase} from "almin";
 class AwesomeUseCase extends UseCase {
    execute(){
        // implementation own use-case
    }
 }
 */
export abstract class UseCase extends Dispatcher implements UseCaseLike {

    /**
     * Debuggable name if it needed
     */
    static displayName?: string;

    /**
     * return true if the `v` is a UseCase.
     */
    static isUseCase(v: any): v is UseCase {
        if (v instanceof UseCase) {
            return true;
        } else if (typeof v === "object" && typeof v.execute === "function") {
            return true;
        }
        return false;
    }


    /**
     * unique id in each UseCase instances.
     */
    id: string;

    /**
     * The default is UseCase name
     */
    name: string;

    constructor() {
        super();

        this.id = generateNewId();
        const own = this.constructor as typeof UseCase;
        this.name = own.displayName || own.name || defaultUseCaseName;
    }


    /**
     * getter to get context of UseCase
     * @returns the UseCaseContext has `execute()` method
     */
    get context(): UseCaseContext {
        return new UseCaseContext(this);
    }

    /**
     * `execute()` method should be overwrite by subclass.
     *
     *  FIXME: mark this as `abstract` property.
     */
    execute<R>(..._: Array<any>): R {
        throw new TypeError(`should be overwrite ${this.constructor.name}#execute()`);
    }

    /**
     * dispatch action object.
     * StoreGroups receive this action and reduce state.
     * @param   payload
     * @param   [meta] meta is internal arguments
     * @override
     */
    dispatch(payload: DispatchedPayload, meta?: DispatcherPayloadMeta) {
        // system dispatch has meta
        // But, when meta is empty, the `payload` object generated by user
        const useCaseMeta = meta
            ? meta
            : new DispatcherPayloadMetaImpl({
                // this dispatch payload generated by this UseCase
                useCase: this,
                // dispatcher is the UseCase
                dispatcher: this,
                // parent is the same with UseCase. because this useCase dispatch the payload
                parentUseCase: null,
                // the user create this payload
                isTrusted: false
            });
        super.dispatch(payload, useCaseMeta);
    }

    /**
     * called the `errorHandler` with error when error is occurred.
     */
    onError(errorHandler: (error: Error) => void): (this: Dispatcher) => void {
        return this.onDispatch(payload => {
            if (isErrorPayload(payload)) {
                errorHandler((payload).error);
            }
        });
    }

    /**
     * throw error event
     * you can use it instead of `throw new Error()`
     * this error event is caught by dispatcher.
     */
    throwError(error?: Error | any): void {
        const meta = new DispatcherPayloadMetaImpl({
            useCase: this,
            dispatcher: this,
            isTrusted: true
        });
        const payload = new ErrorPayload({
            error
        });
        this.dispatch(payload, meta);
    }
}
