// LICENSE : MIT
"use strict";

import * as assert from "assert";
import { EventEmitter } from "events";
import { DispatcherPayloadMetaImpl } from "./DispatcherPayloadMeta";

import { Payload } from "./payload/Payload";
import { ErrorPayload } from "./payload/ErrorPayload";
import { CompletedPayload } from "./payload/CompletedPayload";
import { DidExecutedPayload } from "./payload/DidExecutedPayload";
import { WillExecutedPayload } from "./payload/WillExecutedPayload";

export const ON_DISPATCH = "__ON_DISPATCH__";

/**
 *  Actual payload object types
 */
export type DispatchedPayload = Payload | ErrorPayload | CompletedPayload | DidExecutedPayload | WillExecutedPayload;

/**
 * Dispatcher is the **central** event bus system.
 *
 * also have these method.
 *
 * - `onDispatch(function(payload){  });`
 * - `dispatch(payload);`
 *
 * Almost event pass the (on)dispatch.
 *
 * ### FAQ
 *
 * Q. Why use `Payload` object instead emit(key, ...args).
 *
 * A. It is for optimization and limitation.
 * If apply emit style, we cast ...args for passing other dispatcher at every time.
 */
export class Dispatcher extends EventEmitter {
    /**
     * if {@link v} is instance of Dispatcher, return true
     */
    static isDispatcher(v: any): v is Dispatcher {
        if (v instanceof Dispatcher) {
            return true;
        } else if (typeof v === "object" && typeof v.onDispatch === "function" && typeof v.dispatch === "function") {
            return true;
        }
        return false;
    }

    constructor() {
        super();
        // suppress: memory leak warning of EventEmitter
        // Dispatcher can listen more than 10 events
        this.setMaxListeners(0);
    }

    /**
     * add onAction handler and return unbind function
     * @param   handler
     * @returns call the function and release handler
     */
    onDispatch(handler: (payload: DispatchedPayload, meta: DispatcherPayloadMetaImpl) => void): () => void {
        this.on(ON_DISPATCH, handler);
        return this.removeListener.bind(this, ON_DISPATCH, handler);
    }

    /**
     * dispatch action object.
     * StoreGroups receive this action and reduce state.
     * @param payload
     * @param [meta]    meta is internal arguments
     */
    dispatch(payload: DispatchedPayload, meta?: DispatcherPayloadMetaImpl): void {
        if (process.env.NODE_ENV !== "production") {
            assert.ok(payload !== undefined && payload !== null, "payload should not null or undefined");
            assert.ok(typeof payload.type !== "undefined", "payload's `type` should be required");
            if (meta !== undefined) {
                assert.ok(meta instanceof DispatcherPayloadMetaImpl, "`meta` object is internal arguments.");
            }
        }
        // `meta` must be generated by system
        if (meta instanceof DispatcherPayloadMetaImpl) {
            this.emit(ON_DISPATCH, payload, meta);
        } else {
            // the `payload` object generated by user
            const dispatchOnlyMeta = new DispatcherPayloadMetaImpl({
                dispatcher: this,
                isTrusted: false
            });
            this.emit(ON_DISPATCH, payload, dispatchOnlyMeta);
        }
    }

    /**
     * delegate payload object to other dispatcher.
     * @param   toDispatcher
     * @returns call the function and release handler
     */
    pipe(toDispatcher: Dispatcher): () => void {
        const fromName = this.constructor.name;
        const toName = toDispatcher.constructor.name;
        const displayName = `delegate-payload:${fromName}-to-${toName}`;

        type DelegatePayloadFn = {
            (payload: DispatchedPayload, meta: DispatcherPayloadMetaImpl): void;
            displayName: string;
        };
        const delegatePayload = function delegatePayload(payload: DispatchedPayload, meta: DispatcherPayloadMetaImpl) {
            (delegatePayload as DelegatePayloadFn).displayName = displayName;
            toDispatcher.dispatch(payload, meta);
        };
        return this.onDispatch(delegatePayload);
    }
}