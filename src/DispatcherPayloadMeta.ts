// LICENSE : MIT
"use strict";

import { Dispatcher } from "./Dispatcher";
import { UseCase } from "./UseCase";

export interface DispatcherPayloadMetaArgs {
    useCase?: UseCase;
    dispatcher?: Dispatcher | Dispatcher;
    parentUseCase?: UseCase | null;
    /**
     *  true if the payload object is generated by Almin.
     */
    isTrusted?: boolean;
}

export interface DispatcherPayloadMeta {
    /**
     * A reference to the useCase/dispatcher to which the payload was originally dispatched.
     */
    readonly useCase: UseCase | null;

    /**
     * A dispatcher of the payload
     * In other word, the payload is dispatched by `this.dispatcher`
     *
     * ## dispatcher in a useCase
     *
     * In following example, this.dispatcher is same with this.useCase.
     *
     * class Example extends UseCase {
     *     execute(){
     *        this.dispatch({ type })
     *        ^^^^
     *        === this dispatcher === this.useCase
     *     }
     * }
     */
    readonly dispatcher: UseCase | Dispatcher | null;

    /**
     * A parent useCase of the `this.useCase`,
     * When useCase is nesting, parentUseCase is a UseCase.
     */
    readonly parentUseCase: UseCase | Dispatcher | null;

    /**
     * A timeStamp is created time of the meta.
     */
    readonly timeStamp: number;

    /**
     * If the payload object is generated by Almin, true
     * The use can use it for detecting "Is the payload generated by system(almin)?".
     * It is similar with https://www.w3.org/TR/DOM-Level-3-Events/#trusted-events
     */
    readonly isTrusted: boolean;
}
/**
 * DispatcherPayloadMeta is a meta object for dispatcher.
 * If `isTrusted` is true, the object is created by System(= Almin).
 * The user can get this meta object together with dispatched `payload` object
 * @example
 * context.onDispatch((payload, meta) => {
 *    console.log(meta);
 * });
 */
export class DispatcherPayloadMetaImpl implements DispatcherPayloadMeta {
    readonly useCase: UseCase | null;
    readonly dispatcher: UseCase | Dispatcher | null;
    readonly parentUseCase: UseCase | Dispatcher | null;
    readonly timeStamp: number;
    readonly isTrusted: boolean;

    constructor({
        useCase,
        dispatcher,
        parentUseCase,
        isTrusted
    }: DispatcherPayloadMetaArgs = {}) {
        this.useCase = useCase || null;
        this.dispatcher = (dispatcher === undefined) ? null : dispatcher;
        this.parentUseCase = parentUseCase || null;
        this.timeStamp = Date.now();
        this.isTrusted = !!isTrusted;
    }
}