<style>
h2 { 
    border-bottom: 1px solid gray;
}
</style>

Almin's API Reference.

See also [Component of Almin](../abstract).

# API Reference

## `Dispatcher`

**Extends EventEmitter**

Dispatcher is the **central** event bus system.

also have these method.

-   `onDispatch(function(payload){  });`
-   `dispatch(payload);`

Almost event pass the (on)dispatch.

#### FAQ

Q. Why use `Payload` object instead emit(key, ...args).

A. It is for optimization and limitation.
If apply emit style, we cast ...args for passing other dispatcher at every time.

### `onDispatch(handler: function (payload: DispatchedPayload, meta: DispatcherPayloadMeta)): Function`

add onAction handler and return unbind function

**Parameters**

-   `handler`: **function (payload: DispatchedPayload, meta: DispatcherPayloadMeta)**

Returns: **[Function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function)** - call the function and release handler

### `dispatch(payload: DispatchedPayload, meta: [DispatcherPayloadMeta])`

dispatch action object.
StoreGroups receive this action and reduce state.

**Parameters**

-   `payload`: **DispatchedPayload**
-   `meta`: **\[DispatcherPayloadMeta]** - meta is internal arguments

### `pipe(toDispatcher: Dispatcher): Function`

delegate payload object to other dispatcher.

**Parameters**

-   `toDispatcher`: **Dispatcher**

Returns: **[Function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function)** - call the function and release handler

### `isDispatcher(v: (Dispatcher | Any)): boolean`

if [v](v) is instance of Dispatcher, return true

**Parameters**

-   `v`: **(Dispatcher | Any)**

Returns: **[boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)**

## `useCase`

A reference to the useCase/dispatcher to which the payload was originally dispatched.

## `dispatcher`

A dispatcher of the payload
In other word, the payload is dispatched by `this.dispatcher`

### dispatcher in a useCase

In following example, this.dispatcher is same with this.useCase.

class Example extends UseCase {
    execute(){
       this.dispatch({ type })
       ^^^^
       === this dispatcher === this.useCase
    }
}

## `parentUseCase`

A parent useCase of the `this.useCase`,
When useCase is nesting, parentUseCase is a UseCase.

## `timeStamp`

A timeStamp is created time of the meta.

## `isTrusted`

If the payload object is generated by Almin, true
The use can use it for detecting "Is the payload generated by system(almin)?".
It is similar with <https://www.w3.org/TR/DOM-Level-3-Events/#trusted-events>

## `defaultStoreName`

A UseCase `dispatch(payload)` and subscribers of the dispatcher are received the payload.

**Examples**

```javascript
abcUseCase
 .dispatch({
     type: "ABC",
     value: "value"
 })

abcStore
 .onDispatch(({ type, value }) => {
     console.log(type);  // "ABC"
     console.log(value); // 42
 });
```

## `Store`

**Extends Dispatcher**

Store class

### `getState(prevState: Object): Object`

should be overwrite. return state object

**Parameters**

-   `prevState`: **[Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)**

Returns: **[Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)** - nextState

### `onError(handler: function (payload: Payload, meta: DispatcherPayloadMeta)): Function`

invoke `handler` when UseCase throw error events.

**Parameters**

-   `handler`: **function (payload: Payload, meta: DispatcherPayloadMeta)**

**Examples**

```javascript
store.onError((payload, meta) => {
 const useCase = meta.useCase;
 if(useCase instanceof AUseCase){
     console.log(payload.error);
 }
}):
```

Returns: **[Function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function)** - call the function and release handler

### `onChange(cb: Function): Function`

subscribe change event of the state(own).
if emit change event, then call registered event handler function

**Parameters**

-   `cb`: **[Function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function)**

Returns: **[Function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function)** - call the function and release handler

### `emitChange()`

emit "change" event to subscribers

### `isStore(v: Any): boolean`

return true if the `v` is store.

**Parameters**

-   `v`: **Any**

Returns: **[boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)**

## `StoreGroup`

**Extends Dispatcher**

StoreGroup is a **UI** parts of Store.
StoreGroup has event queue system.
It means that StoreGroup thin out change events of stores.
If you want to know all change events, and directly use `store.onChange()`.

### `constructor(stores: Array<Store>)`

Create StoreGroup

**Parameters**

-   `stores`: **[Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)&lt;Store>** - stores are instance of `Store` class

### `getState(): Object`

return the state object that merge each stores's state

Returns: **[Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)** - merged state object

### `emitChange()`

emit Change Event

### `onChange(handler: function (stores: Array<Store>)): Function`

listen changes of the store group.

**Parameters**

-   `handler`: **function (stores: [Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)&lt;Store>)** - the callback arguments is array of changed store.

Returns: **[Function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function)** - call the function and release handler

### `release()`

release all events handler.
You can call this when no more call event handler

## `QueuedStoreGroup`

**Extends Dispatcher**

### Description

-   QueuedStoreGroup is a **UI** parts of Store.
-   QueuedStoreGroup has event queue system.
-   QueuedStoreGroup not dependent on async function like `setTimeout`.
-   QueuedStoreGroup work as Sync or Async.
-   QueuedStoreGroup prefer strict design than ./StoreGroup.js

### Checking Algorithm

QueuedStoreGroup check changed stores and `QueuedStoreGroup#emitChange()` (if necessary) on following case:

-   when receive `didExecutedUseCase` events
-   when receive events by `UseCase#dispatch`
-   when receive events by `UseCase#throwError`

### Note

-   QueuedStoreGroup not allow to change **stores** directly.
-   Always change **stores** via execution of UseCase.
-   QueuedStoreGroup has not cache state.
-   Cache system should be in your Store.

### `constructor(stores: Array<Store>, options: [Object])`

Create StoreGroup

**Parameters**

-   `stores`: **[Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)&lt;Store>** - stores are instance of `Store` class
-   `options`: **\[[Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)]** - QueuedStoreGroup option

### `getState(): Object`

return the state object that merge each stores's state

Returns: **[Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)** - merged state object

### `emitChange()`

emit change event

### `onChange(handler: function (stores: Array<Store>)): Function`

listen changes of the store group.

**Parameters**

-   `handler`: **function (stores: [Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)&lt;Store>)** - the callback arguments is array of changed store.

Returns: **[Function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function)** - call the function and release handler

### `release()`

release all events handler.
You can call this when no more call event handler

## `UseCase`

**Extends Dispatcher**

UseCase class is inherited Dispatcher.
The user implement own user-case that is inherited UseCase class

**Examples**

```javascript
import {UseCase} from "almin";
class AwesomeUseCase extends UseCase {
    execute(){
        // implementation own use-case
    }
}
```

### `context`

getter to get context of UseCase

Returns: **UseCaseContext** - the UseCaseContext has `execute()` method

### `execute()`

`execute()` method should be overwrite by subclass.

### `dispatch(payload: DispatchedPayload, meta: [DispatcherPayloadMeta])`

dispatch action object.
StoreGroups receive this action and reduce state.

**Parameters**

-   `payload`: **DispatchedPayload**
-   `meta`: **\[DispatcherPayloadMeta]** - meta is internal arguments

### `onError(errorHandler: function (error: Error)): function (this: Dispatcher)`

called the `errorHandler` with error when error is occurred.

**Parameters**

-   `errorHandler`: **function (error: [Error](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error))**

Returns: **function (this: Dispatcher)**

### `throwError(error: [(Error | Any)])`

throw error event
you can use it instead of `throw new Error()`
this error event is caught by dispatcher.

**Parameters**

-   `error`: **\[([Error](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) | Any)]**

### `isUseCase(v: Any): boolean`

return true if the `v` is a UseCase.

**Parameters**

-   `v`: **Any**

Returns: **[boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)**

## `UseCaseContext`

UseCase internally use UseCaseContext insteadof Context.
It has limitation as against to Context.
Because, UseCaseContext is for UseCase.

### `constructor(dispatcher: (UseCase))`

**Parameters**

-   `dispatcher`: **(UseCase)** - dispatcher is the parent UseCase.

### `useCase(useCase: UseCase): UseCaseExecutor`

Create UseCaseExecutor for `useCase`.

**Parameters**

-   `useCase`: **UseCase**

Returns: **UseCaseExecutor**

## `Context`

### `constructor({ dispatcher, store })`

**Parameters**

-   `dispatcher`: **Dispatcher**
-   `store`: **(QueuedStoreGroup | StoreGroup | Store)** - store is either Store or StoreGroup

### `getState(): Any`

return state value of StoreGroup.

Returns: **Any** - states object of stores

### `onChange(onChangeHandler: function (changingStores: Array<Store>)): Function`

if anyone store is changed, then call onChangeHandler

**Parameters**

-   `onChangeHandler`: **function (changingStores: [Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)&lt;Store>)**

Returns: **[Function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function)** - release handler function.

### `useCase(useCase: UseCase): UseCaseExecutor`

**Parameters**

-   `useCase`: **UseCase**

**Examples**

```javascript
context.useCase(UseCaseFactory.create()).execute(args);
```

Returns: **UseCaseExecutor**

### `onWillExecuteEachUseCase(handler: function (payload: WillExecutedPayload, meta: DispatcherPayloadMeta))`

called the [handler](handler) with useCase when the useCase will do.

**Parameters**

-   `handler`: **function (payload: WillExecutedPayload, meta: DispatcherPayloadMeta)**

### `onDispatch(handler: function (payload: DispatchedPayload, meta: DispatcherPayloadMeta)): Function`

called the `handler` with user-defined payload object when a UseCase dispatch with payload.
This `onDispatch` is not called at built-in event. It is filtered by Context.
If you want to _All_ dispatched event and use listen directly your `dispatcher` object.
In other word, listen the dispatcher of `new Context({dispatcher})`.

**Parameters**

-   `handler`: **function (payload: DispatchedPayload, meta: DispatcherPayloadMeta)**

Returns: **[Function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function)**

### `onDidExecuteEachUseCase(handler: function (payload: DidExecutedPayload, meta: DispatcherPayloadMeta))`

called the `handler` with useCase when the useCase is executed..

**Parameters**

-   `handler`: **function (payload: DidExecutedPayload, meta: DispatcherPayloadMeta)**

### `onCompleteEachUseCase(handler: function (payload: CompletedPayload, meta: DispatcherPayloadMeta))`

called the `handler` with useCase when the useCase is completed.

**Parameters**

-   `handler`: **function (payload: CompletedPayload, meta: DispatcherPayloadMeta)**

### `onErrorDispatch(handler: function (payload: ErrorPayload, meta: DispatcherPayloadMeta)): function (this: Dispatcher)`

called the `errorHandler` with error when error is occurred.

**Parameters**

-   `handler`: **function (payload: ErrorPayload, meta: DispatcherPayloadMeta)**

Returns: **function (this: Dispatcher)**

### `release()`

release all events handler.
You can call this when no more call event handler

## `UseCaseExecutor`

UseCaseExecutor is a helper class for executing UseCase.

### `constructor({ useCase, parent, dispatcher })`

**Parameters**

-   `useCase`: **UseCase**
-   `parent`: **(UseCase | null)** - parent is parent of `useCase`
-   `dispatcher`: **(Dispatcher | UseCase)**

### `onWillExecuteEachUseCase(handler: function (payload: WillExecutedPayload, meta: DispatcherPayloadMeta))`

called the [handler](handler) with useCase when the useCase will do.

**Parameters**

-   `handler`: **function (payload: WillExecutedPayload, meta: DispatcherPayloadMeta)**

### `onDidExecuteEachUseCase(handler: function (payload: DidExecutedPayload, meta: DispatcherPayloadMeta))`

called the `handler` with useCase when the useCase is executed.

**Parameters**

-   `handler`: **function (payload: DidExecutedPayload, meta: DispatcherPayloadMeta)**

### `onCompleteExecuteEachUseCase(handler: function (payload: CompletedPayload, meta: DispatcherPayloadMeta)): Function`

called the `handler` with useCase when the useCase is completed.

**Parameters**

-   `handler`: **function (payload: CompletedPayload, meta: DispatcherPayloadMeta)**

Returns: **[Function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function)**

### `execute(args: ...)`

execute UseCase instance.
UseCase is a executable object. it means that has `execute` method.

**Parameters**

-   `args`: **...**

### `release()`

release all events handler.
You can call this when no more call event handler

## `type`

`type` is unique property of the payload.
A `type` property which may not be `undefined`
It is a good idea to use string constants or Symbol for payload types.
